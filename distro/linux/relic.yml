---
tokens:
  # PKCS#11 tokens on which signing keys can be found
  mytoken:
    # Full path to provider library
    provider: /usr/lib64/softhsm/libsofthsm.so
    # Optional selectors to pick a token from those the provider offers
    label: alpha
    serial: 99999
    # PIN is optional for command-line use, but required for servers. See also 'pinfile'.
    pin: 123456
    #pin: "" # blank PIN, without prompting

    # Optional login user. Useful values:
    # 0 - CKU_SO
    # 1 - CKU_USER (default)
    # 2 - CKU_CONTEXT_SPECIFIC, SafeNet: CKU_AUDIT
    # 0x80000001 - SafeNet: CKU_LIMITED_USER
    #user: 1
tools:
  # Servers can also invoke a predefined command-line tool to sign packages
  signtool:
    # Template for tool command-line. Variables:
    # - {file} - Path to the file to be signed
    # - {key} - defined in the key section below
    # - {certificate} - defined in the key section below
    command: '"C:\\signtool.exe" sign /f {certificate} /csp myprovider /kc {key} {file}'
keys:
  # Two kinds of keys exist: token keys, and tool keys
  my_token_key:
    # Which token, defined above, to find the key on
    token: mytoken
    # Optional selectors to pick a key from those in the token
    # CKA_LABEL:
    label: "label"
    # CKA_ID:
    id: 00112233
    # Path to a PGP certificate, if PGP signing is desired. Can be ascii-armored or binary.
    pgpcertificate: ./keys/rsa1.pub
    # Path to a X509 certificate, if X509 signing is desired. Can be PEM, DER,
    # or PKCS#7 (p7b) format, with optional certificate chain.
    x509certificate: ./keys/rsa1.cer
    # true if a RFC 3161 timestamp should be attached, see 'timestamp' below
    timestamp: false
    roles: ['somegroup']
  my_tool_key:
    # Which tool, defined above, to use the key with
    tool: mytool
    # Arbitrary string to substitute for {key}
    key: keyname
    # Arbitrary string to substitute for {x509certificate}
    x509certificate: c:/mycert.cer
    # List of user-roles that are permitted to use this key
    roles: ['somegroup']
server:
  # What port to listen on. Defaults to :6300.
  # Socket activation via systemd is also supported, in which case this is ignored.
  listen: ":6300"
  # Private key for server TLS. PEM format, RSA or ECDSA
  keyfile: /etc/relic/server/server.key
  # X.509 certificate for server TLS. PEM format. If a cert chain is needed it
  # should follow the main cert.
  certfile: /etc/relic/server/server.key
  # Optional logfile for server errors. If not set, then standard error is used
  logfile: /var/log/relic/server.log
  # Maximum number of bytes to buffer in RAM (i.e. for PGP clearsign)
  maxdocsize: 10000000
# Instead of including token PINs in this file, you can specify an alternate
# "pin file" which is a YAML file holding key-value pairs where the key is the
# name of the token and the value is the PIN.
#pinfile: /etc/relic/pin.yaml
timestamp:
  # RFC 3161 timestamp server(s). If more than one is provided then they will
  # be tried in the order given until one succeeds. Only keys with 'timestamp:
  # true' are affected, and only when performing signature types that accept a
  # timestamp.
  urls:
    - http://mytimestamp.server/rfc3161
  # Optional timeout for each timestamp request
  timeout: 60
  # Optional alternate CA certificate file for contacting timestamp servers
  # cacert: /etc/pki/tls/mychain.pem
amqp:
  # Optional audit logging to an AMQP broker
  #url: amqp://guest:guest@127.0.0.1:5672
  # "fanout" type exchange to send audit messages to, default relic.signatures
  # sigsXchg: relic.signatures
  # Name of key to use to "seal" audit messages using a PKCS#7 signedData
  # structure
  #sealingKey: my_token_key

clients:
  # Authentication to the server is via client certificate. Certificates are
  # identified by their fingerprint. Fingerprints can be obtained by using the
  # "relic remote register" command on the client to generate the key, or by
  # checking the server error log after attempting to connect.
  E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855:
    # Display name for this client
    nickname: myuser
    # List of roles this user possesses. Must contain at least one of the roles
    # on a key for the user to access that key.
    roles: ['somegroup']
